pragma solidity 0.4.24;
contract Entity {
   address public owner;
   address[] public users;
   Request[] public requests;
   
   struct User {
      uint8 userType;
      uint8 instit;
   }
   
   struct Request {
       address initiator;
       uint256 amount;
       uint8 validPolice;
       uint8 validRepair;
       uint8 status;
       string desc;
       string append;
   }
   
   // The address of the player => the user info   
   // so playerInfo[some_address].amountBet gives the amount
   mapping(address => User) public userInfo;
   event TransferFund(address transferTo, address transferFrom, uint amount);

   // Fallback function in case someone sends ether to the contract so it doesn't 
   // get lost and to increase the treasury of this contract that will be distributed in each game
   function() public payable {}

   constructor() public {
      owner = msg.sender;
      userInfo[owner].userType = 1;
      userInfo[owner].instit = 1;
      // placeholder for position 0
      users.push(owner);
      users.push(owner);
   }

   function kill() public {
      if(msg.sender == owner) selfdestruct(owner);
   }
    
    function checkUser(address user) public constant returns(uint256){
      for(uint256 i = 1; i < users.length; i++){
            if(users[i] == user) return i;
      }
      return 0;
    }

   function add(address user, uint8 userType) public returns(bool) {
      require(userInfo[msg.sender].userType == 1);
      if( checkUser(user) == 0){
        userInfo[user].userType = userType;
        userInfo[user].instit = userInfo[msg.sender].instit;
        users.push(user);
        return true;
      }
      return false;
   }
    
    // test purpose function, to be removed
    function resetData() public {
        require(msg.sender == owner);
        users.length = 0; // Delete all the players array
    }
   
   // Operations
   // Functions for transactions and requests
   
    function requestClaim(uint8 flagP, uint8 flagR, string desc, uint256 amount) public returns(uint256){
        require(userInfo[msg.sender].userType > 2);
        // make sure flags are not set to completed
        if(flagP >1 || flagR > 1) return 0;
        requests.push(Request({
                                initiator: msg.sender,
                                amount: amount,
                                validPolice: flagP, 
                                validRepair: flagR,
                                status: 0,
                                desc: desc,
                                append: ""
        }));
        
        return requests.length - 1;
    } 
/*   
    function validate() public{
        uint8 me = checkUser(msg.sender);
        if(me.userType == 2){
            
        }
        else if (me.userType == 3){
            
        }
    }
*/    
    function payClaim(uint256 req, uint256 amount) payable public returns(bool) {
        require(userInfo[msg.sender].userType == 1);
        emit TransferFund(requests[req].initiator, 
                        msg.sender, 
                        amount);
        return true;
    }
}